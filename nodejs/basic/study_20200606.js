// 関数

// プリミティブなパラメータ(数値など)は値渡しで関数に渡されるため、関数がパラメータの値を変更しても、その変更はグローバルな値や関数の呼び出しには影響を与えない。
// オブジェクト(非プリミティブ値、Array やユーザー定義オブジェクトなど)を引数として渡すと、関数がパラメータの値を変更した場合、その変更が関数外でも有効になる。

// 関数式
// 関数は関数式によって作成することもできる。このような関数は無名にできる。
// 無名関数
var square = function (number) {  return number * number  };
var x = square(4);
console.log(x);                 // 16

// 関数式には名前をつけることもできる。関数内で自身を参照することや、デバッガーのスタックトレースで関数を特定することに利用できる。
var factorial = function fac(n) {  return n<2 ? 1 : n*fac(n-1)  };
console.log(factorial(3));      // 6

// 関数式はある関数を別の関数の引数として渡すときに便利。
function map(f, a) {
  let result = []; // 新しい配列を作成
  let i; // 変数の宣言
  for (i = 0; i != a.length; i++)
    result[i] = f(a[i]);
  return result;
}
var f = function(x) {
   return x * x * x; 
}
var numbers = [0, 1, 2, 5, 10];
var cube = map(f,numbers);
console.log(cube);

// JS は、条件に基づいて関数を定義することができる。
// 例: 変数 num が 0 に等しい場合のみ myFunc という関数を定義する。
var myFunc;
if (num == 0){
  myFunc = function(theObject) {
    theObject.make = "Toyota"
  }
}

// メソッド: オブジェクトのプロパティである関数のこと。

// 関数の呼び出し
// 関数の宣言は、関数の呼び出しより後に置くことができる。
// 関数式の場合、定義を呼び出しより後に書くと、変数の巻き上げが行われてしまうので、動作しない。
// 関数は、その関数自身を呼び出すことができる。
function factorial(n){
  if ((n == 0) || (n == 1))
    return 1;
  else
    return (n * factorial(n - 1));
}

// 関数のスコープ
// 関数の内部で宣言された変数は関数の外部からアクセスすることができない。
// 関数は自身が定義されたスコープ内で定義されている全ての変数、関数にアクセスできる。

// スコープと関数スタック

// 再帰
// 関数が自身を参照する方法は3種類ある:
// 関数名: bar() など
// arguments.callee: arguments.callee
// 関数を参照したスコープ内変数: foo() など
// 上記3つは全て同じ意味となる(自身を呼び出す関数のことを再帰関数という)。
// 再帰関数を使用すると、単純な反復ループだけでは行えないアルゴリズムも実装できちゃう。
function walkTree(node) {
  if (node == null) // 
    return;
  // ノードに対し処理を行う
  for (var i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}

// スタックのふるまい
// 再帰を使用すると、スタックが使用できる(関数スタック)。
function foo(i) {
  if (i < 0)
    return;
  console.log('begin:' + i);
  foo(i - 1);
  console.log('end:' + i);
}
foo(3);

// 出力:

// begin:3
// begin:2
// begin:1
// begin:0
// end:0
// end:1
// end:2
// end:3

// 入れ子の関数とクロージャ
// 関数の中に関数を入れ子(ネスト)することができる。内部の関数は、外部の関数からはプライベートになる(クロージャ)。
// 入れ子になった関数はクロージャなので。つまり、入れ子になった関数は内包する関数に引き数と変数を、「継承」することができるということになる。別の言い方をすれば、内部の関数は外部の関数のスコープを持っているということになる。
// まとめ
// ・内部の関数へは、外部関数内の文からのみアクセスが可能。
// ・内部の関数はクロージャとなる。クロージャは外部関数の引数と変数を利用でき、一方で外部関数は内部の引数と変数を利用できない。
function addSquares(a,b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
a = addSquares(2,3); // 13 を返す
b = addSquares(3,4); // 25 を返す
c = addSquares(4,5); // 41 を返す

// 内部の関数はクロージャとなるので、外部の関数からクロージャを呼びだし、外部と内部の両方の関数に対し引数を指定することができる。
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}
fn_inside = outside(3); // このように考えてください : 与えられたものに 3 を加算する関数を代入します
result = fn_inside(5); // 8 を返す

result1 = outside(3)(5); // 8 を返す

// 変数の保護
// クロージャはそれ自身が参照している全てのスコープ内の引数と変数を保護することになる。それぞれの呼び出しには異なる引数が渡される可能性があるので、それぞれの outside の呼び出しに対し新しいクロージャが作られる。返された inside がもはやアクセスできなくなったときのみメモリーは開放される。
// これはその他オブジェクトの内部で参照を保持する場合と違いはないが、クロージャの場合は直接参照を設定せず、また情報を取得できないので、明白さは劣る。

// 多重入れ子関数
// 関数は多重に入れ子にすることができる。関数を入れ子にすることで、クロージャは多重スコープを導入できる。関数のスコープが再帰的に包含されている(スコープチェーンという)。
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // 6 がログに出力される (1 + 2 + 3)
// C は B、さらに A の引数と変数にアクセスできる。言い換えれば、C は B、A の順でスコープがつながっている(cain)。
// その一方で、逆は成り立たない。A は C にアクセスできない。A は C を変数の一つとして持っている B の変数や引数にアクセスできないから(外部がクロージャにアクセスできるのは文からのみ)。C は B からのみプライベートとなっている。

// 名前衝突
// クロージャ中のスコープに同じ名前の2つの引数や変数がある場合、名前衝突が生ずる。より内部のスコープが優先されるので、最内部にあるスコープが最優先に、最も外側のスコープが最も低い優先度となる。これがスコープチェーン。チェーンの最初は最内部のスコープ、そして最後は最外部のスコープとなる。
function outside() {
  var x = 10;
  function inside(x) {
    return x;
  }
  return inside;
}
result = outside()(20); // 10 ではなく 20 を返す
// 文 return x の箇所で、inside の 引数 x と outside の変数 x との間に名前衝突が起きている。ここでのスコープチェーンは、{inside, outside, グローバルオブジェクト} となる。したがって、inside の x が outside の x より優先されて、結果 20 (inside の x) が優先される。
